000100000000      *---------------------------------------------------------
000200000000      * Source information
000300000000      * @@LIBRARY: GITTEST123
000400000000      * @@FILE: QRPGLESRC2
000500000000      * @@MEMBER: MONOSTDOU3
000600000000      * @@TYPE: RPGLE
000700000000      * @@TEXT: Read and parse stdout log....xxxzxaaa
000800000000      *---------------------------------------------------------
000900000000     /***************************************************************
001000000000      * Program: MONOSTDOUT
001100000000      * Author : Richard J Schoen
001200000000      * Desc . : This program will read the selected STDOUT log file and
001300000000      *          send back info to the caller for processing the
001400000000      *          selected log messages. MONOSTDOUT is created in QTEMP
001500000000      *          at runtime.
001600000000      *          Uses its own custom CPF message: NET9898 which
001700000000      *          stands for Mono/.Net message.
001800000000      *          This way .Net console messages can be picked out of
001900000000      *          the joblog if desired by CPF Message
002000000000      ***************************************************************/
002100000000     H DFTACTGRP(*NO) ACTGRP(*NEW)
002200000000
002300000000     FMONOSTDOUTIF   F 1000        DISK    USROPN
002400000000      /include QSYSINC/QRPGLESRC,QUSEC
002500000000      //  SEND Program Message API
002600000000
002700000000     D QMHSNDPM        PR                  ExtPgm('QMHSNDPM')
002800000000     D  szMsgID2                      7A   Const
002900000000     D  szMsgFile2                   20A   Const
003000000000     D  szMsgData2                 6000A   Const OPTIONS(*varsize)
003100000000     D  nMsgDataLen                  10I 0 Const
003200000000
003300000000      **  Message Type may be one of the following:
003400000000      **  *COMP    - Completion
003500000000      **  *DIAG    - Diagnostic
003600000000      **  *ESCAPE  - Escape
003700000000      **  *INFO    - Informational
003800000000      **  *INQ     - Inquiry.
003900000000      **             (Only used when ToPgmQ(*EXT) is specified).
004000000000      **  *NOTIFY  - Notify
004100000000      **  *RQS     - Request
004200000000      **  *STATUS  - Status
004300000000     D  szMsgType                    10A   Const
004400000000
004500000000      **  Call Stack Entry may be one of the following:
004600000000      **  *        - *SAME
004700000000      **  *EXT     - The external message queue
004800000000      **  *CTLBDY  - Control Boundary
004900000000      **  *PRV     - Program that called this procedure (*SAME)
005000000000      **  *PRVPGM  - Previous programo
005100000000     D  szCallStkEntry...
005200000000     D                               10A   Const
005300000000     D  nRelativeCallStkEntry...
005400000000     D                               10I 0 Const
005500000000     D  szRtnMsgKey                   4A
005600000000     D  apiErrorDS                         LikeDS(QUSEC)
005700000000     D                                     OPTIONS(*VARSIZE)
005800000000
005900000000      // TODO: Include the QMHSNDPM API Prototype here
006000000000
006100000000     D SndMsg          PR             4A
006200000000     D  szMsg                      1024A   Const Varying
006300000000     D  szMsgType                    10A   Const
006400000000     D                                     OPTIONS(*NOPASS)
006500000000     D  szToPgmQ                     10A   Const
006600000000     D                                     OPTIONS(*NOPASS)
006700000000
006800000000     IMONOSTDOUTAA  01
006900000000     I                                  1  400  LOGDATA
007000000000     I                                  1   40  LOG40
007100000000     I                                 13  112  LOGRTN
007200000000     I                                  1    5  PARM5
007300000000
007400000000     C     *ENTRY        PLIST
007500000000     C                   PARM                    EXEFILE         255
007600000000     C*                  PARM                    RTNP1           100
007700000000     C*                  PARM                    RTNP2           100
007800000000
007900000000      /free
008000000000
008100000000      /IF DEFINED(*CRTBNDRPG)
008200000000
008300000000       //  Read STDOUT log file now
008400000000       OPEN MONOSTDOUT;
008500000000
008600000000       // Stdout being message
008700000000       SndMsg('------------------------------':'*INFO':'*PRVPGM') ;
008800000000       SndMsg('Program:' + %trim(exefile):'*INFO':'*PRVPGM');
008900000000       SndMsg('Begin .Net Stdout':'*INFO':'*PRVPGM');
009000000000       SndMsg('------------------------------':'*INFO':'*PRVPGM') ;
009100000000
009200000000       // Loop thru STDOUT results
009300000000       READ MONOSTDOUT;
009400000000       DOW Not %EOF(MONOSTDOUT);
009500000000
009600000000         // Pick off the return parm values
009700000000         // and set the return fields.
009800000000        SndMsg(%TRIM(LogData):'*INFO':'*PRVPGM');
009900000000
010000000000        //IF PARM5 = 'PARM1';
010100000000        //    RTNP1 = LOGRTN;
010200000000        //ELSEIF PARM5 = 'PARM2';
010300000000        //    RTNP2 = LOGRTN;
010400000000        //ENDIF;
010500000000         READ MONOSTDOUT;
010600000000
010700000000       ENDDO;
010800000000
010900000000       SndMsg('------------------------------':'*INFO':'*PRVPGM') ;
011000000000       SndMsg('End .Net Stdout':'*INFO':'*PRVPGM');
011100000000       SndMsg('------------------------------':'*INFO':'*PRVPGM') ;
011200000000
011300000000       CLOSE MONOSTDOUT;
011400000000
011500000000       // All done, let's bail out
011600000000       *inlr = *on;
011700000000       return;
011800000000
011900000000      /end-free
012000000000      /ENDIF
012100000000
012200000000     P SndMsg          B                   Export
012300000000      *******************************************
012400000000      **  Send an impromptu message to a pgmq
012500000000      *******************************************
012600000000     D SndMsg          PI             4A
012700000000     D  msg                        1024A   Const Varying
012800000000     D  szMsgType                    10A   Const
012900000000     D                                     OPTIONS(*NOPASS)
013000000000     D  szToPgmQ                     10A   Const
013100000000     D                                     OPTIONS(*NOPASS)
013200000000
013300000000      *******************************************
013400000000      /include qsysinc/qrpglesrc,qusec
013500000000      *******************************************
013600000000      **  Local variables.
013700000000     D  msgType        S                   Like(szMsgType) Inz('*INFO')
013800000000     D  toPgmQ         S                   Like(szToPgmQ)  Inz('*')
013900000000
014000000000     D msgid           S              7A   Inz('NET9898')
014100000000     D msgf            DS            21
014200000000     D  MsgFile                      10A   Inz('MONOMSG')
014300000000     D  MsgLib                       10A   Inz('*LIBL')
014400000000     D
014500000000     D msgData         S           1024A
014600000000     D nDataLen        S             10I 0 Inz(0)
014700000000     D nRelInv         S             10I 0 Inz(1)
014800000000     D nIncInv         S             10I 0 Inz(1)
014900000000     D RtnMsgKey       S              4A
015000000000     D myAPIErrorDS    DS                  LikeDS(QUSEC)
015100000000
015200000000     C                   eval      myApiErrorDS = *ALLX'00'
015300000000
015400000000     C                   if        %Parms()>=2
015500000000     C                   eval      msgType = szMsgType
015600000000     C                   if        %subst(msgType:1:1)<>'*'
015700000000     C                   eval      msgType = '*' + %TrimL(msgType)
015800000000     C                   endif
015900000000     C                   endif
016000000000
016100000000     C                   if        %Parms()>= 3
016200000000     C                   if        szToPgmQ <> *BLANKS
016300000000     C                   eval      toPgmQ=  szToPgmQ
016400000000     C                   endif
016500000000     C                   if        toPgmQ = '*SAME'
016600000000     C                   eval      toPgmQ = '*'
016700000000     C                   endif
016800000000     C                   endif
016900000000
017000000000         // Status messages always go ToPgmQ(*EXT)
017100000000     C                   if        msgType = '*STATUS'
017200000000     C                   eval      toPgmQ = '*EXT'
017300000000     C                   endif
017400000000
017500000000     C                   if        msgType = '*'
017600000000     C                   eval      msgType = '*INFO'
017700000000     C                   endif
017800000000
017900000000        // Get the length of the message to be sent.
018000000000     C                   eval      msgData = %Trim(msg)
018100000000     C                   eval      nDataLen = %len(%Trim(msg))
018200000000
018300000000     C                   Select
018400000000      **  *SAME
018500000000     C                   when      toPgmQ  = ' '
018600000000     C                             or toPgmQ = '*SAME'
018700000000     C                             or toPgmQ = '*'
018800000000     C                   eval      toPgmQ = '*'
018900000000     C                   eval      nRelInv = 0
019000000000     C                   eval      nIncInv = 1
019100000000      **  *PRV, *PRVPRC or *PRVPROC
019200000000     C                   when      toPgmQ = '*PRVPRC'
019300000000     C                             or toPgmQ = '*PRVPROC'
019400000000     C                             or toPgmQ = '*PRV'
019500000000     C                   eval      toPgmQ = '*'
019600000000     C                   eval      nRelInv = 1
019700000000     C                   eval      nIncInv = 1
019800000000      **  *PRVPGM
019900000000     C                   When      toPgmQ = '*PRVPGM'
020000000000     C                   eval      toPgmQ = '*CTLBDY'
020100000000     C                   eval      nRelInv = 0
020200000000     C                   eval      nIncInv = 1
020300000000      **  *CTLBDY
020400000000     C                   when      toPgmQ = '*CTLBDY'
020500000000     C                   eval      nIncInv = 2
020600000000      **  *EXT
020700000000     C                   when      toPgmQ = '*EXT'
020800000000     C                   eval      nRelInv = 0
020900000000     C                   endsl
021000000000
021100000000      **  Since we're a relative invocation, and we are
021200000000      **  one-level deep, we need to bump up the relative
021300000000      **  invocation by the calculated increment.
021400000000     C                   eval      nRelInv = nRelInv + nIncInv
021500000000
021600000000     C                   callp(e)  QMHSNDPM(msgid   : msgf :
021700000000     C                                      msgData : nDataLen :
021800000000     C                                      msgType   :
021900000000     C                                      toPgmQ    :
022000000000     C                                      nRelInv   :
022100000000     C                                      rtnMsgKey :
022200000000     C                                      myAPIErrorDS)
022300000000
022400000000     C                   return    rtnMsgKey
022500000000     P SndMsg          E
022600000000
